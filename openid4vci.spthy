theory OpenID4VCI
begin

builtins: hashing, asymmetric-encryption, signing, revealing-signing

restriction Equality: "All x y #i. Eq(x,y) @i ==> x = y"

// Register key
rule Register_pk:
    [ Fr(~ltk) ]
  -->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

// Get key
// Adversary can always get any public key
rule Get_pk:
    [ !Pk(A, pubkey) ]
    -->
    [ Out(pubkey) ]

rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
    --[ LtkReveal(A) ]->
    [ Out(ltk) ]

/*
    Modeling secure channal
*/

rule ChanOut_S:
        [ Out_S($A,$B,x) ]
        --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]


// User enters claims in browser
// Browser sends POST request to issuer vis TLS
rule User_create_offer:
    [ ]
    -->
    [ Out_S($user, $issuer, $claims), St_usr_1($claims)]


// Init credential offer on issuer
// and send it to wallet e.g. scanning qr code
rule Issuer_credential_offer:
    let credential_offer = <~code, $issuer> in
    [ In_S($user, $issuer, $claims), Fr(~code)]
    -->
    [ Out_S($issuer, $wallet, credential_offer), St_iss_1($issuer, ~code), St_iss_map(~code, $claims)]


// Wallet consumes offer and requests token
rule Wallet_token_req:
    let credential_offer = <~code, $issuer>
        token_req = <pkWal, ~code>
    in
    [ In_S($issuer, $wallet, credential_offer),
        !Ltk($wallet, ~ltkWal), !Pk($wallet, pkWal) ]
    -->
    [ Out_S($wallet, $issuer, token_req), St_wal_1($wallet, ~code)]

rule Issuer_token_res:
    let token_req = <~client_id, ~code>

        // token is JWT signed by issuer
        // important part of JET is code in payload which includes code
        token = revealSign(~code, ~ltkIss)
        // here is missing expires_in, c_nounce_expires_in
        // authorisation_pending and interval fields
        token_res = <token, ~c_nounce>
    in
    [ In_S($wallet, $issuer, token_req),
        !Ltk($issuer, ~ltkIss),
        Fr(~c_nounce), St_iss_1($issuer, ~code) ]
    -->
    [ Out_S($issuer, $wallet, token_res), St_iss_2($issuer, ~code, ~c_nounce) ]

rule Wallet_credential_request:
    let 
        token_res = <token, ~c_nounce>
        proof = revealSign(~c_nounce, ~ltkWal)

        // Missing fields are types which is list of credential types
        // then format. Proof fields contains string proof_type and
        // JWT which is signed by wallet. JWT contains c_nounce
        // which we get from token response
        credential_req = <token, proof>
    in
    [In_S($issuer, $wallet,token_res),
        !Ltk($wallet,~ltkWal), !Pk($issuer, pkIss),
        St_wal_1($wallet, ~code)]

    --[Eq(revealVerify(token, ~code, pkIss), true)]->

    [Out_S($wallet, $issuer,credential_req), St_wal_2($wallet, ~code, token)]

rule Issuer_credential_response:
    let
        //TODO check if token is signed by issuer
        // c_nounce from credential_req needs to be same as in
        // token response
        
        // Credential offer has fields credential, format, c_nounce
        // which needs to be same as in credential_req
        // and c _nounce_expires_in
        // Credential is JWT signed by issuer
        // I SUPPOSE that most important part of JWT is
        // iss and sub which are pub keys of issuer and wallet
        credential_req = <token, proof>

        credential = revealSign(<pkIss, pkWal, $claims>, ~ltkIss)
        credential_res = <credential, ~c_nounce>
    in
    [In_S($wallet, $issuer,credential_req),
        St_iss_2($issuer, ~code, ~c_nounce), St_iss_map(~code, $claims),
        !Ltk($issuer, ~ltkIss), !Pk($issuer, pkIss), !Pk($wallet, pkWal)]
    
    // token is code signed by Iss
    // proof is nounce signed by wall
    --[Eq(revealVerify(token, ~code, pkIss), true),
        Eq(revealVerify(proof, ~c_nounce, pkWal), true),
        Credential_is_issued(credential, pkIss)]->

    [Out_S($issuer, $wallet,credential_res)]

    // At the end user checks credential and decides
    // to accept it or not

rule Wallet_accept_credential:
        let credential_res = <credential, ~c_nounce>
        in
        [In_S($issuer, $wallet, credential_res),
            !Ltk($wallet,~ltkWall), !Pk($wallet, pkWal),!Pk($issuer, pkIss)]

        --[Eq(revealVerify(credential, getMessage(credential), pkIss), true)]->

        [Out_S($wallet, $user, credential)]

rule User_accept_credential:
    let credential = <pkIssFromCredential, pkWalFromCredential, claimsFromCredential>
    in
    [In_S($wallet, $user, credential), St_usr_1($claims)]
    --[Eq($claims, claimsFromCredential)]->
    [!Wallet_has(credential)]


rule User_Create_Presentation:
    []
    -->
    [Out_S($user, $verifier, $claims), St_ver_1($claims)]

// verifier creates request, stores it, shows qr code containing path to wallet
rule Verifier_shows_path_to_auth_req:
    [In_S($user, $verifier, $claims),
         Fr(~corrId), Fr(~state), Fr(~nounce)]
    -->
    [!St_ver_store_reqest($claims, ~corrId, ~state, ~nounce),
        Out_S($verifier, $wallet, ~corrId)//this is scanning qr code
    ]

// wallet send POST request containg corrId to get Request object
rule Wallet_asks_for_auth_req:
    [In_S($verifier, $wallet, ~corrId)]
    -->
    [Out_S($wallet, $verifier, ~corrId)]// this is POST req via TLS

rule Verifier_sends_auth_req:
    let authReq = revealSign(<~nounce,~state>, ~ltkVer)
    in
    [In_S($wallet, $verifier, ~corrId),
    !St_ver_store_reqest($claims, ~corrId, ~state, ~nounce),
    !Ltk($verifier,~ltkVer)]
    -->
    [Out_S($verifier, $wallet, authReq)]

rule Wallet_sends_auth_res:
    let credential = <pkIssFromCredential, pkWalFromCredential, claimsFromCredential>
        authReq = <~nounce,~state>
        authRes = revealSign(<~nounce, ~state, credential,pkWal>,~ltkWal)
    in
    [In_S($verifier, $wallet, authReq),
        !Wallet_has(credential),
        !Pk($wallet, pkWal),!Pk($verifier, pkVer), !Ltk($wallet, ~ltkWal)]
    --[/*provjeri je li auth req ispravno potpisan od verifiera*/
        Eq(revealVerify(authReq, getMessage(authReq), pkVer), true)]->
    [Out_S($wallet, $verifier, authRes)]

rule Verifier_consumes_response:
/*
    stari pokušaj
    let authResM = getMessage(authRes)
        authResM = <nounceRecv, stateRecv, credentialRecv, pkWalRecv>
        credentialRecvM = getMessage(credentialRecv)
        credentialRecvM = <pkIssFromCredential, pkWalFromCredential, claimsFromCredential>
*/
    let authRes = <~nounceRecv, ~stateRecv, credentialRecv, pkWalRecv>
        //credentialRecv = <pkIssFromCredential, pkWalFromCredential, claimsFromCredential>
        // ovo ovdje gore se ne uspjeva dekonstruirati zato je zakomentirano
        // koristi se u donjem dijelu za provjeru jednakosti
    in
    [In_S($wallet, $verifier, authRes),
        !St_ver_store_reqest($claims, ~corrId, ~state, ~nounce),
        !Pk($wallet, pkWal),!Pk($issuer, pkIss)]

    --[/*provjeri je li authRes potpisan od walleta*/
        Eq(revealVerify(authRes, getMessage(authRes), pkWal), true),
        Eq(pkWalRecv, pkWal),
        /*provjeri je li credential potpisan od issuera*/
        Eq(revealVerify(credentialRecv, getMessage(credentialRecv), pkIss), true),
        //Eq(pkWalFromCredential, pkWal),
        //Eq(pkIssFromCredential, pkIss),
        /*provjeri je li credential sadržava claimove*/
        //Eq(claimsFromCredential, $claims),
        Credential_is_presented(credentialRecv, pkIss),
        Finish()]->

    []
    
    

// modeling security properties of protocol
lemma executable:
    exists-trace
        " Ex #i. Finish()@i
            & not (Ex b #k. LtkReveal(b)@k) "
// ova lemma exacutable ne prolazi
// ne vidim dokaz u interaktivnom načinu
end // makni ovaj end da se učita cijela skrita tu je stavljen jer
    // drugi dio sadržava sintaktičku grešku

// Credential_is_presented(credentialRecv, pkIss)
// Credential_is_issued(credential, pkIss)
// Za svaki prezentiran credentialRecv postoji izdan credential
// i pkIss stvarno dolazi od $issuer
// ova lemma ima neku sintaktičku grešku
lemma credential_is_authentific:
    " All cr #i.
        (Credential_is_presented(cr, pkI)@i
        ==> (Ex cre #j. Credential_is_issued(cre, iss)
            & pkI=iss
            & cre=cr
            & j<i))"

end
