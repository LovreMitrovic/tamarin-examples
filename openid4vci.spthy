theory OpenID4VCI
begin

builtins: hashing, asymmetric-encryption, signing, revealing-signing

restriction Equality: "All x y #i. Eq(x,y) @i ==> x = y"

// Register key
rule Register_pk:
    [ Fr(~ltk) ]
  -->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

// Get key
// Adversary can always get any public key
rule Get_pk:
    [ !Pk(A, pubkey) ]
    -->
    [ Out(pubkey) ]

rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
    --[ LtkReveal(A) ]->
    [ Out(ltk) ]

/*
    Modeling secure channal
    https://tamarin-prover.com/manual/master/book/011_advanced-features.html#confidential-channel-rules
*/
rule ChanOut_C:
        [ Out_C($A,$B,x) ]
      --[ ChanOut_C($A,$B,x) ]->
        [ !Conf($B,x) ]

rule ChanIn_C:
        [ !Conf($B,x), In($A) ]
      --[ ChanIn_C($A,$B,x) ]->
        [ In_C($A,$B,x) ]

rule ChanIn_CAdv:
    [ In(<$A,$B,x>) ]
        -->
        [ In_C($A,$B,x) ]

// User enters claims in browser
// Browser sends POST request to issuer vis TLS
rule User_create_offer:
    [ ]
    -->
    [ Out_C($user, $issuer, $claims), St_usr_1($claims)]


// Init credential offer on issuer
// and send it to wallet e.g. scanning qr code
rule Issuer_credential_offer:
    let credential_offer = <~code, $issuer> in
    [ In_C($user, $issuer, $claims), Fr(~code)]
    -->
    [ Out_C($issuer, $wallet, credential_offer), St_iss_1($issuer, ~code), St_iss_map(~code, $claims)]


// Wallet consumes offer and requests token
rule Wallet_token_req:
    let credential_offer = <~code, $issuer>
        token_req = <pkWal, ~code>
    in
    [ In_C($issuer, $wallet, credential_offer),
        !Ltk($wallet, ~ltkWal), !Pk($wallet, pkWal) ]
    -->
    [ Out_C($wallet, $issuer, token_req), St_wal_1($wallet, ~code)]

rule Issuer_token_res:
    let token_req = <~client_id, ~code>

        // token is JWT signed by issuer
        // important part of JET is code in payload which includes code
        token = revealSign(~code, ~ltkIss)
        // here is missing expires_in, c_nounce_expires_in
        // authorisation_pending and interval fields
        token_res = <token, ~c_nounce>
    in
    [ In_C($wallet, $issuer, token_req),
        !Ltk($issuer, ~ltkIss),
        Fr(~c_nounce), St_iss_1($issuer, ~code) ]
    -->
    [ Out_C($issuer, $wallet, token_res), St_iss_2($issuer, ~code, ~c_nounce) ]

rule Wallet_credential_request:
    let 
        token_res = <token, ~c_nounce>
        proof = revealSign(~c_nounce, ~ltkWal)

        // Missing fields are types which is list of credential types
        // then format. Proof fields contains string proof_type and
        // JWT which is signed by wallet. JWT contains c_nounce
        // which we get from token response
        credential_req = <token, proof>
    in
    [In_C($issuer, $wallet,token_res),
        !Ltk($wallet,~ltkWal), !Pk($issuer, pkIss),
        St_wal_1($wallet, ~code)]

    --[Eq(revealVerify(token, ~code, pkIss), true)]->

    [Out_C($wallet, $issuer,credential_req), St_wal_2($wallet, ~code, token)]

rule Issuer_credential_response:
    let
        //TODO check if token is signed by issuer
        // c_nounce from credential_req needs to be same as in
        // token response
        
        // Credential offer has fields credential, format, c_nounce
        // which needs to be same as in credential_req
        // and c _nounce_expires_in
        // Credential is JWT signed by issuer
        // I SUPPOSE that most important part of JWT is
        // iss and sub which are pub keys of issuer and wallet
        credential_req = <token, proof>

        credential = revealSign(<pkIss, pkWal, $claims>, ~ltkIss)
        credential_res = <credential, ~c_nounce>
    in
    [In_C($wallet, $issuer,credential_req),
        St_iss_2($issuer, ~code, ~c_nounce), St_iss_map(~code, $claims),
        !Ltk($issuer, ~ltkIss), !Pk($issuer, pkIss), !Pk($wallet, pkWal)]
    
    // token is code signed by Iss
    // proof is nounce signed by wall
    --[Eq(revealVerify(token, ~code, pkIss), true),
        Eq(revealVerify(proof, ~c_nounce, pkWal), true)]->

    [Out_C($issuer, $wallet,credential_res)]

    // At the end user checks credential and decides
    // to accept it or not

rule Wallet_accept_credential:
        let credential_res = <credential, ~c_nounce>
        in
        [In_C($issuer, $wallet, credential_res),
            !Ltk($wallet,~ltkWall), !Pk($wallet, pkWal),!Pk($issuer, pkIss)]

        --[Eq(revealVerify(credential, getMessage(credential), pkIss), true)]->

        [Out_C($wallet, $user, credential)]

rule User_accept_credential:
    let credential = <pkIssFromCredential, pkWalFromCredential, claimsFromCredential>
    in
    [In_C($wallet, $user, credential), St_usr_1($claims)]
    --[Eq($claims, claimsFromCredential),
        Finish()]->
    []

// modeling security properties of protocol
lemma executable:
    exists-trace
        " Ex #i. Finish()@i
            & not (Ex b #k. LtkReveal(b)@k) "

end
